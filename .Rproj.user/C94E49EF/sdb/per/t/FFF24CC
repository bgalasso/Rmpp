{
    "collab_server" : "",
    "contents" : "###########################################################################################################################\n#### calculate the barycentre. for this we need to choose a base measure\n#### and to calculate the inverses of the smoothed distribution functions\n###########################################################################################################################\n\n#### base measure\nnubase <- function(x)\tspike.smooth(whoisbase, x)\n\ninverses <- function(j, q) # from [0, 1] to R\tF_j^{-1}(q)\n{\n  res <- numeric(l <- length(q))\n  #\tif(q > 1)  stop(paste(j, q, \"q should be in ]0, 1[\"))\n  \n  #\tprint(paste(\"inverses: j\", j, \"q\", q))\n  for(i in 1:l)\n    res[i] <- uniroot(function(x) spike.smooth(j, x) - q[i], interval = c(0, 1) , maxiter = 100, tol=0.001)$root\n  \n  res\n}\n\nmean.inverses <- function(q, w = rep(1 / Ntrain, Ntrain)) # from [0, 1] to R  (1/n)sum F_j^{-1}(q)\n{\n  res <- 0\n  #\tprint(paste(\"mean inverses: q\", q))\n  for(j in 1:Ntrain)\n    res <- res + w[j] * inverses(j, q)\n  # DOES NOT WORK res <- w * sapply(1:Ntrain, FUN = inverses, q = q)\n  \n  res\n}\n\nbary.fun <- function(x, w = rep(1 / Ntrain, Ntrain)) # from R to R\t(1/n)sum F_j^{-1}(F_1(x))\n  mean.inverses(nubase(x), w = w)\n#### this is the function T such that F = T#F1 (replace 1 by whoisbase)\n\nbary.dist <- function(x, w = rep(1 / Ntrain, Ntrain)) # from R to [0, 1]  F_1( baryfunperb^{-1}(x) )\n{# distribution function of the Frechet mean\n  inv <- numeric(l <- length(x))\n  \n  for(i in 1:l)\n    inv[i] <- uniroot(function(y) bary.fun(y, w = w) - x[i], interval = c(0, 1) , maxiter = 100, tol=0.001)$root\n  \n  nubase(inv)\n}\n#### this equals the inverse of mean.inverses\nif(status_f == 1){\nprint(\"calculating the distribution function of the Fr\\u{E9}chet mean...\")\nbarytime <- system.time(baryvals <- if(PARALLEL) unlist(parallel::mclapply(xx, mc.cores = CORES, FUN = bary.dist)) else bary.dist(xx)   )\nprint(paste(\"this took\", barytime[3], \"seconds\"))\n}\n\n\n#MEANS <- cbind(xx, baryvals , arithvals, base.dist(xx))\n#colnames(MEANS) <- c(\"xx\", \"wass\", \"arith\", \"true\")\n#write.table(MEANS, file = paste(\"means\", nametxt, sep = \"\"), col.names = TRUE, row.names = FALSE)\n#res$MEANS <- MEANS\n\nif(status_w == 1){\nprint(paste(\"calculating the\", Ntrain, \"warp functions...\"))\nwarpinv <- matrix(ncol = Ntrain, nrow = lgrid)\nwarpfuntime <- system.time(if(PARALLEL)\n{\n  warpinv.list <- parallel::mclapply(1:Ntrain, mc.cores = CORES, FUN = function(j)\n  {\n    print(j)\n    mean.inverses(spike.smooth(j, xx))\n  })\n  for(j in 1:Ntrain)\n    warpinv[, j] <- warpinv.list[[j]]\n  rm(warpinv.list)\n}\nelse\n{\n  for(j in 1:Ntrain)\n  {\n    warpinv[, j] <- mean.inverses(spike.smooth(j, xx))\n    #### this is the function Tj such that F = Tj#Fj\n    print(j)\n  }\n})\nprint(paste(\"this took\", warpfuntime[3], \"seconds\"))\n#write.table(warpinv, file = paste(\"warpfuninv\", nametxt, sep = \"\"), col.names = FALSE, row.names = FALSE)\n#### these are the *inverses* of the warp functions\n#res$warpinv <- warpinv\n}\n\nif(status_a == 1){\nprint(\"aligning...\")\naligned.spike.mat <- spike.mat\naligntime <- system.time(if(PARALLEL)\n{\n  align.list <- parallel::mclapply(1:Ntrain, mc.cores = CORES, FUN = function(j)\n  {\n    print(j)\n    mean.inverses(spike.smooth(j,   spike.mat[1:Npoints[j], j]   ))\n  })\n  for(j in 1:Ntrain)\n    aligned.spike.mat[1:Npoints[j], j] <- align.list[[j]]\n  rm(align.list)\n}\nelse\n{\n  for(j in 1:Ntrain)\n  {\n    pts <- spike.mat[1:Npoints[j], j]\n    aligned.spike.mat[1:Npoints[j], j] <- mean.inverses(spike.smooth(j, pts))\n    # print(j)\n  }\n})\nprint(paste(\"this took\", aligntime[3], \"seconds\"))\n#write.table(aligned.spike.mat, file = paste(\"aligned\", nametxt, sep = \"\"), col.names = FALSE, row.names = FALSE)\n#res$registered <- aligned.spike.mat\n}\n#wr <- c(a1 <- barytime[3], a2 <- warpfuntime[3], a3 <- aligntime[3],  a1 + a2 + a3)\n#names(wr) <- c(\"mean\", \"warp\", \"align\", \"total\")\n#write.table(wr, file = paste(\"time\", nametxt, sep = \"\"), col.names = FALSE)\n#res$time <- wr\n\n\n#res <- list(warped = spike.mat, bw = bw, means = MEANS, warpinv = warpinv, aligned = aligned.spike.mat, time = wr)\n#save(res, file = paste(\"warpWass\", nameFR, sep = \"\"))",
    "created" : 1559356930892.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3783022553",
    "id" : "FFF24CC",
    "lastKnownWriteTime" : 1519420196,
    "last_content_update" : 1519420196,
    "path" : "~/Dropbox/Doctorado en Estadistica/BNP Point Processes/Numerical Experiments/warp_bayesian.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}