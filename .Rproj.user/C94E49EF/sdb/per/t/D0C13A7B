{
    "collab_server" : "",
    "contents" : "require(DPpackage)\nrequire(caTools)\nrequire(fda.usc)\nrequire(fda)\nrequire(ROCstudio)\n\nN <- 30 ##Number of realizations\npoints <- 50 ## Expected number of points for each realization\nmu <- c(1/4, 3/4) ##Means\nsigma <- c(.02,.03) ###SD\nS <- 10 ### Number of iterations\nw <- c(.2,.8) ## Weights\nlgrid <- 2^8 ## length grid\nxx <- seq(0,1,length.out = 2^8) ## Grid\nPARALLEL <- TRUE\nCORES <- parallel::detectCores()\n\nset.seed(23102017)\n\n###Original Data\n\nY <- Poisson_points <- list()\nfor(s in 1:S){\n  Npoints <- rpois(N, points)\n  AUX <- matrix(NA, nrow=max(Npoints),ncol=N)\n  for(i in 1:N){\n  aux <- sample(c(1,2),Npoints[i],replace = T,prob = w)\n  AUX[1:Npoints[i],i] <- rnorm(Npoints[i],mean = mu[aux],sd = sigma[aux])\n  }\n  Poisson_points[[s]] <-  Npoints\n  Y[[s]] <- AUX\n}\n\n\n## Warping functions and Warping data\n\nwarp_function <- warp_data <- list()\nfor(s in 1:S){\nK <- matrix(rpois(N*2, lambda = 3) * sample(c(-1,1),2*N,replace = T,prob = c(1/2,1/2)), ncol = 2)\nU <- runif(N)\nperb <- function(k,x) if(k==0) 0 else sin(pi*k*x)/(abs(k)*pi)\nwarping <- function(x,k){\n  a <- x - perb(K[k,2],x) + U[k]*(perb(K[k,2],x)-perb(K[k,1],x))\n  return(a)\n}\n\n\nfunctions <- matrix(NA,nrow=lgrid,ncol=N)\ndata <- matrix(NA,nrow=max(Poisson_points[[s]]),ncol=N)\n\nfor(k in 1:N){\n  data[1:Poisson_points[[s]][k],k] <- warping(na.omit(Y[[s]][,k]),k)\n  functions[,k] <- warping(xx,k)\n}\nwarp_function[[s]] <- functions\nwarp_data[[s]] <- data\n}\n\n### Estimation\n\nstate <- NULL\n\n## MCMC\n\nnburn <- 500\nnsave <- 4500\nnskip <- 0\nndisplay <- 100\nmcmc <- list(nburn=nburn,nsave=nsave,nskip=nskip,ndisplay=ndisplay)\n\n\n## Prior\n\nprior<-list(aa0=2,ab0=2,kmax=1000,a0=1,b0=1)\n\n## Bernstein adjust\nfit_berns <- list()\n\nfor(s in 1:S){\n  fit <- array(NA,dim=c(lgrid,nsave,N))\n  for(k in 1:N){\n  aux <- BDPdensity(y=na.omit(warp_data[[s]][,k]),support = 1, prior = prior,grid = xx , mcmc=mcmc,state=state,status = TRUE)\n  fit[,,k] <- matrix(aux$fun,nrow=lgrid)\n  print(k)\n  }\n  fit_berns[[s]] <- fit\n}\n\nf_hat <- matrix(NA,ncol=N,nrow=lgrid)\nfor(k in 1:N)\n  f_hat[,k] = apply(fit_berns[[1]][,,k],1,mean)\n\n\n\n### Distribution functions\n\nBD.dist <- function(y,k,s,t){\n  a <- c()\n  for(i in 1:length(y)){\n    aux = y[i]\n    a[i] <- sum(fit_berns[[s]][which(xx <= aux),t,k])/sum(fit_berns[[s]][,t,k])\n  }\n  a\n}\n\n### Bayesian version\n\nwarp_bayesian <- align_bayesian <- list()\n\nfor(s in 1:S){\n  Ntrain <- N\n  Npoints <- Poisson_points[[s]]\n  spike.mat <- warp_data[[s]]\n  whoisbase <- 1\n  status_f = 0\n  status_w = 0\n  status_a = 1\n  warp_traj <- array(NA,dim=c(lgrid,N,nsave))\n  alig_traj <- array(NA, dim=c(max(Poisson_points[[s]]),N,nsave))\n  for(t in 1:nsave){\n    spike.smooth <- function(j,x) BD.dist(x,j,s,t)\n    source(\"/Users/bastiangalasso/Dropbox/Doctorado en Estadistica/BNP Point Processes/Numerical Experiments/warp_bayesian.R\")\n    #warp_traj[,,t] <- warpinv\n    alig_traj[,,t] <- aligned.spike.mat \n    if(t%%10 == 0){\n      print(t)\n    }\n    #if(t%%500 == 0){\n    #  save(warp_traj,alig_traj,file = paste(\"test\",t,\".RData\",sep=\"\"))\n    #}\n  }\n  #warp_bayesian[[s]] <- warp_traj\n  save(alig_traj,file = paste(\"alig_traj_\",s,\".Rdata\",sep=\"\"))\n  align_bayesian[[s]] <- alig_traj\n}\n\n\n\n# ### Panaretos and Zemel version\n# \n# warp_kernel <- align_kernel <- list()\n# \n# for(s in 1:S){\n#   Ntrain <- N\n#   Npoints <- Poisson_points[[s]]\n#   spike.mat <- warp_data[[s]]\n#   source(\"/Users/bastiangalasso/Dropbox/Doctorado en Estadistica/BNP Point Processes/Numerical Experiments/warp.R\")\n#   warp_kernel[[s]] <- warpinv\n#   align_kernel[[s]] <- aligned.spike.mat\n# }\n# \n# ####Plots\n# \n# ###Original Data\n# \n# plot(Y[[1]][,1],rep(1,length(Y[[1]][,1])),type=\"p\",lwd=1,xlim=c(0,1),ylim=c(0,31),ylab=\" \",xlab=\" \")\n# for (k in 1:N)\n#   points(Y[[1]][,k],rep(k, length(Y[[1]][,k])), pch = 16, \n#          col = colorRampPalette(c(\"blue\", \"violet\", \"red\", \"orange\"))(30)[k])\n# \n# ###Original Warp functions\n# \n# plot(xx,warping(xx,1),type=\"l\",lwd=2,ylim=c(0,1),xlab=\"y\",ylab=\"T\")\n# for(k in 1:N)\n#   lines(xx,warping(xx,k),lwd=2,col = colorRampPalette(c(\"blue\", \"violet\", \"red\", \"orange\"))(30)[k])\n# \n# ###Warped Data\n# \n# plot(warp_data[[1]][,1],rep(1,length(warp_data[[1]][,1])),type=\"p\",lwd=1,xlim=c(0,1),ylim=c(0,31),ylab=\" \",xlab=\" \")\n# for (k in 1:N)\n#   points(warp_data[[1]][,k],rep(k, length(warp_data[[1]][,k])), pch = 16, \n#          col = colorRampPalette(c(\"blue\", \"violet\", \"red\", \"orange\"))(30)[k])\n# \n# ###Estimated fs\n# \n# plot(xx,f_hat[,1],type=\"l\",lwd=2,ylim=c(0,20),xlab=\"y\",ylab=\"T\")\n# for(k in 1:N)\n#   lines(xx,f_hat[,k],lwd=2,col = colorRampPalette(c(\"blue\", \"violet\", \"red\", \"orange\"))(30)[k])\n# \n# ###Estimated Warped Functions BD\n# \n# plot(xx,warp_hat[,1],type=\"l\",lwd=2,ylim=c(0,1),xlab=\"y\",ylab=\"T\")\n# for(k in 1:N)\n#   lines(xx,warp_hat[,k],lwd=2,col = colorRampPalette(c(\"blue\", \"violet\", \"red\", \"orange\"))(30)[k])\n# \n# ###Estimated Warped Functions Kernel\n# \n# plot(xx,warpinv[,1],type=\"l\",lwd=2,ylim=c(0,1),xlab=\"y\",ylab=\"T\")\n# for(k in 1:N)\n#   lines(xx,warpinv[,k],lwd=2,col = colorRampPalette(c(\"blue\", \"violet\", \"red\", \"orange\"))(30)[k])\n# \n# ###Registered Points BD\n# \n# plot(align_hat[,1],rep(1,length(align_hat[,1])),type=\"p\",lwd=1,xlim=c(0,1),ylim=c(0,31),ylab=\" \",xlab=\" \",main=\"Bayesian\")\n# for (k in 1:N)\n#   points(align_hat[,k],rep(k, length(align_hat[,k])), pch = 16, \n#          col = colorRampPalette(c(\"blue\", \"violet\", \"red\", \"orange\"))(30)[k])\n# \n# ###Registered Points Kernel\n# \n# plot(aligned.spike.mat[,1],rep(1,length(aligned.spike.mat[,1])),type=\"p\",lwd=1,xlim=c(0,1),ylim=c(0,31),ylab=\" \",xlab=\" \",main=\"Kernel\")\n# for (k in 1:N)\n#   points(aligned.spike.mat[,k],rep(k, length(aligned.spike.mat[,k])), pch = 16, \n#          col = colorRampPalette(c(\"blue\", \"violet\", \"red\", \"orange\"))(30)[k])\n",
    "created" : 1559356907464.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "354860756",
    "id" : "D0C13A7B",
    "lastKnownWriteTime" : 1518614177,
    "last_content_update" : 1518614177,
    "path" : "~/Dropbox/Doctorado en Estadistica/BNP Point Processes/Numerical Experiments/Simulation.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}