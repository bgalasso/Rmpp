{
    "collab_server" : "",
    "contents" : "require(DPpackage)\nrequire(caTools)\nrequire(fda.usc)\nrequire(fda)\nrequire(ROCstudio)\n\nN <- 30 ##Number of realizations\npoints <- 50 ## Expected number of points for each realization\nmu <- c(1/4, 3/4) ##Means\nsigma <- c(.02,.03) ###SD\nS <- 5 ### Number of iterations\nw <- c(.2,.8) ## Weights\nlgrid <- 2^8 ## length grid\nxx <- seq(0,1,length.out = 2^8) ## Grid\nPARALLEL <- TRUE\nCORES <- parallel::detectCores()\n\nset.seed(2032018)\n\n###Original Data\n\nY <- Poisson_points <- list()\nfor(s in 1:S){\n  Npoints <- rpois(N, points)\n  AUX <- matrix(NA, nrow=max(Npoints),ncol=N)\n  for(i in 1:N){\n  aux <- sample(c(1,2),Npoints[i],replace = T,prob = w)\n  AUX[1:Npoints[i],i] <- rnorm(Npoints[i],mean = mu[aux],sd = sigma[aux])\n  }\n  Poisson_points[[s]] <-  Npoints\n  Y[[s]] <- AUX\n}\n\n\n## Warping functions and Warping data\n\nwarp_function <- warp_data <- list()\nfor(s in 1:S){\nK <- matrix(rpois(N*2, lambda = 3) * sample(c(-1,1),2*N,replace = T,prob = c(1/2,1/2)), ncol = 2)\nU <- runif(N)\nperb <- function(k,x) if(k==0) 0 else sin(pi*k*x)/(abs(k)*pi)\nwarping <- function(x,k){\n  a <- x - perb(K[k,2],x) + U[k]*(perb(K[k,2],x)-perb(K[k,1],x))\n  return(a)\n}\n\n\nfunctions <- matrix(NA,nrow=lgrid,ncol=N)\ndata <- matrix(NA,nrow=max(Poisson_points[[s]]),ncol=N)\n\nfor(k in 1:N){\n  data[1:Poisson_points[[s]][k],k] <- warping(na.omit(Y[[s]][,k]),k)\n  functions[,k] <- warping(xx,k)\n}\nwarp_function[[s]] <- functions\nwarp_data[[s]] <- data\n}\n\n### Estimation\n\nstate <- NULL\n\n## MCMC\n\nnburn <- 500\nnsave <- 4500\nnskip <- 0\nndisplay <- 100\nmcmc <- list(nburn=nburn,nsave=nsave,nskip=nskip,ndisplay=ndisplay)\n\n\n## Prior\n\nprior<-list(aa0=2,ab0=2,kmax=1000,a0=1,b0=1)\n\n## Bernstein adjust\nfit_berns <- list()\n\nfor(s in 1:S){\n  fit <- array(NA,dim=c(lgrid,nsave,N))\n  for(k in 1:N){\n  aux <- BDPdensity(y=na.omit(warp_data[[s]][,k]),support = 1, prior = prior,grid = xx , mcmc=mcmc,state=state,status = TRUE)\n  fit[,,k] <- matrix(aux$fun,nrow=lgrid)\n  print(k)\n  }\n  fit_berns[[s]] <- fit\n}\n\nsave(fit_berns,file=\"fitberns7.RData\")\n\n#f_hat <- matrix(NA,ncol=N,nrow=lgrid)\n#for(k in 1:N)\n#  f_hat[,k] = apply(fit_berns[[1]][,,k],1,mean)\n\n\n\n### Distribution functions\n\nBD.dist <- function(y,k,s,t){\n  a <- c()\n  for(i in 1:length(y)){\n    aux = y[i]\n    a[i] <- sum(fit_berns[[s]][which(xx <= aux),t,k])/sum(fit_berns[[s]][,t,k])\n  }\n  a\n}\n\n### Bayesian versions\n\nwarp_bayesian <- align_bayesian <- list()\n\nfor(s in 3:4){\n  Ntrain <- N\n  Npoints <- Poisson_points[[s]]\n  spike.mat <- warp_data[[s]]\n  whoisbase <- 1\n  status_f = 0\n  status_w = 0\n  status_a = 1\n  warp_traj <- array(NA,dim=c(lgrid,N,nsave))\n  alig_traj <- array(NA, dim=c(max(Poisson_points[[s]]),N,nsave))\n  for(t in 1:nsave){\n    spike.smooth <- function(j,x) BD.dist(x,j,s,t)\n    source(\"/Users/bastiangalasso/Dropbox/Doctorado en Estadistica/BNP Point Processes/Numerical Experiments/warp_bayesian.R\")\n    #warp_traj[,,t] <- warpinv\n    alig_traj[,,t] <- aligned.spike.mat \n    if(t%%10 == 0){\n      print(t)\n    }\n    #if(t%%500 == 0){\n    #  save(warp_traj,alig_traj,file = paste(\"test\",t,\".RData\",sep=\"\"))\n    #}\n  }\n  save(alig_traj,file = paste(\"alig_traj_\",33+s,\".RData\",sep=\"\"))\n  #warp_bayesian[[s]] <- warp_traj\n  #save(warp_traj,alig_traj,file = \"oneshotexp.RData\")\n  #align_bayesian[[s]] <- alig_traj\n}\n\nsave(Y,warp_data,warp_function,Poisson_points,fit_berns,warp_traj,alig_traj,file = \"oneshotexp.RData\")\n\nal_hat <- list()\nomit <- c()\nnum <- c(1547,1461)\n\nfor(s in 1:2){\n  alig_traj <- array(as.numeric(alig_traj), dim=c(max(Poisson_points[[s]]),N,nsave))\n  align_bayesian[[s]] <- alig_traj\n}\n\nwarp_traj <- array(as.numeric(warp_traj),dim=c(lgrid,N,nsave))\n  i=1\n  omit <- c()\n  for(t in 1:nsave){\n  aux <- length(na.omit(as.numeric(warp_traj[,,t])))\n  if(aux < 7680){\n    omit[i] = t\n    i=i+1\n  }\n  }\n\nwarp_traj <- warp_traj[,,-omit]\nwarp_hat <- matrix(NA,ncol=N,nrow=lgrid)\nfor(k in 1:N)\n  warp_hat[,k] <- apply(warp_traj[,k,],1,mean)\n\nfor(s in 1:2){\n  align_hat <- align_l <- align_u <- matrix(NA,nrow=max(Poisson_points[[s]]),ncol=N)\n  aux <- alig_traj[,,-omit]\n  for(k in 1:N){\n  align_hat[1:Poisson_points[[s]][k],k] <- apply(aux[1:Poisson_points[[s]][k],k,],1,mean)\n  align_l[1:Poisson_points[[s]][k],k] <- apply(aux[1:Poisson_points[[s]][k],k,], 1, quantile, probs = 0.025, na.rm = TRUE)\n  align_u[1:Poisson_points[[s]][k],k] <- apply(aux[1:Poisson_points[[s]][k],k,], 1, quantile, probs = 0.975, na.rm = TRUE)\n  }\n  al_hat[[s]] = align_hat\n}\n\n### Panaretos and Zemel version\n\nwarp_kernel <- align_kernel <- list()\n\nfor(s in 1:S){\n  Ntrain <- N\n  Npoints <- Poisson_points[[s]]\n  spike.mat <- warp_data[[s]]\n  source(\"/Users/bastiangalasso/Dropbox/Doctorado en Estadistica/BNP Point Processes/Numerical Experiments/warp.R\")\n  warp_kernel[[s]] <- warpinv\n  align_kernel[[s]] <- aligned.spike.mat\n}\n# \n####Plots\n\n###Original Data\n\nplot(Y[[2]][,1],rep(1,length(Y[[2]][,1])),type=\"p\",lwd=1,xlim=c(0,1),ylim=c(0,31),ylab=\"i\",xlab=\"t\")\nfor (k in 1:N)\n  points(Y[[2]][,k],rep(k, length(Y[[2]][,k])), pch = 16,\n         col = colorRampPalette(c(\"blue\", \"violet\", \"red\", \"orange\"))(30)[k])\n\n###Original Warp functions\n\nplot(xx,warping(xx,1),type=\"l\",lwd=2,ylim=c(0,1),xlab=\"y\",ylab=\"T\")\nfor(k in 1:N)\n  lines(xx,warping(xx,k),lwd=2,col = colorRampPalette(c(\"blue\", \"violet\", \"red\", \"orange\"))(30)[k])\n\n###Warped Data\n\nplot(warp_data[[2]][,1],rep(1,length(warp_data[[2]][,1])),type=\"p\",lwd=1,xlim=c(0,1),ylim=c(0,31),ylab=\"i\",xlab=\"t\")\nfor (k in 1:N)\n  points(warp_data[[2]][,k],rep(k, length(warp_data[[2]][,k])), pch = 16,\n         col = colorRampPalette(c(\"blue\", \"violet\", \"red\", \"orange\"))(30)[k])\n\n###Estimated fs\n\nplot(xx,f_hat[,1],type=\"l\",lwd=2,ylim=c(0,20),xlab=\"y\",ylab=\"T\")\nfor(k in 1:N)\n  lines(xx,f_hat[,k],lwd=2,col = colorRampPalette(c(\"blue\", \"violet\", \"red\", \"orange\"))(30)[k])\n\n###Estimated Warped Functions BD\n\nplot(xx,warp_hat[,1],type=\"l\",lwd=2,ylim=c(0,1),xlab=\"y\",ylab=\"T\")\nfor(k in 1:N)\n  lines(xx,warp_hat[,k],lwd=2,col = colorRampPalette(c(\"blue\", \"violet\", \"red\", \"orange\"))(30)[k])\n\n###Estimated Warped Functions Kernel\n\nplot(xx,warpinv[,1],type=\"l\",lwd=2,ylim=c(0,1),xlab=\"y\",ylab=\"T\")\nfor(k in 1:N)\n  lines(xx,warpinv[,k],lwd=2,col = colorRampPalette(c(\"blue\", \"violet\", \"red\", \"orange\"))(30)[k])\n\n###Registered Points BD\n\nplot(al_hat[[2]][,1],rep(1,length(al_hat[[2]][,1])),type=\"p\",lwd=1,xlim=c(0,1),ylim=c(0,31),ylab=\"i\",xlab=\"t\",main=\" \")\nfor (k in 1:N)\n  points(al_hat[[2]][,k],rep(k, length(al_hat[[2]][,k])), pch = 16,\n         col = colorRampPalette(c(\"blue\", \"violet\", \"red\", \"orange\"))(30)[k])\n\n###Registered Points Kernel\n\nplot(aligned.spike.mat[,1],rep(1,length(aligned.spike.mat[,1])),type=\"p\",lwd=1,xlim=c(0,1),ylim=c(0,31),ylab=\" \",xlab=\" \",main=\"Kernel\")\nfor (k in 1:N)\n  points(aligned.spike.mat[,k],rep(k, length(aligned.spike.mat[,k])), pch = 16,\n         col = colorRampPalette(c(\"blue\", \"violet\", \"red\", \"orange\"))(30)[k])\n\n#### Ad\nwarphat <- warpl <- warpu <- matrix(NA,nrow=lgrid,ncol=N)\nfor (k in 1:N) {\n  gk <- warp_traj[,k,]\n  warphat[,k] <- apply(gk, 1, mean, na.rm = TRUE)\n  warpl[,k] <- apply(gk, 1, quantile, probs = 0.025, na.rm = TRUE)\n  warpu[,k] <- apply(gk, 1, quantile, probs = 0.975, na.rm = TRUE)\n}\n\nplot(warphat[,5],xx,type = \"l\",ylim=c(0,1),lwd=2, xlab = \"t\" , ylab= \"T\", main=\" \")\npolygon(c(rev(warpl[,5]), warpu[,5]), c(rev(xx), xx),\n        col = \"lightblue\", border = NA)\nlines(warphat[,5],xx,lwd=2)\nlines(xx,warp_function[[1]][,5],lty=2,lwd=2,col=\"gray\")\nlines(warpinv[,5],xx,lwd=2,col=\"red\")\n\nch <- c()\n\nfor(k in 1:N)\n  ch[k] <- sample(c(1:Poisson_points[[2]][k]),1)\n\npar(mfrow=c(1,2))\n\nplot(align_hat[,1],rep(1,length(align_hat[,1])),type=\"p\",lwd=1,xlim=c(0,1),ylim=c(0,31),ylab=\"i\",xlab=\"t\",main=\" \")\nfor (k in 1:N)\n  points(align_hat[,k],rep(k, length(align_hat[,k])), pch = 16,\n         col = colorRampPalette(c(\"blue\", \"violet\", \"red\", \"orange\"))(30)[k])\n\nplot(align_hat[ch[1],1],1,type=\"p\",lwd=1,xlim=c(0,1),ylim=c(0,31),ylab=\"i\",xlab=\"t\",main=\" \")\nfor(k in 1:N){\n  lines(c(align_l[ch[k],k],align_u[ch[k],k]),c(k,k),lwd=2)\n}\nfor (k in 1:N){\n  points(align_hat[ch[k],k],k, pch = 16,\n         col = colorRampPalette(c(\"blue\", \"violet\", \"red\", \"orange\"))(30)[k])\n  }\nfor (k in 1:N){\n  points(align_l[ch[k],k],k, pch = \"|\")\n  points(align_u[ch[k],k],k, pch = \"|\")\n}\n",
    "created" : 1559356832222.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1793909937",
    "id" : "F82A19FA",
    "lastKnownWriteTime" : 1544665565,
    "last_content_update" : 1544665565,
    "path" : "~/Dropbox/Doctorado en Estadistica/BNP Point Processes/Numerical Experiments/Simulation BG.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}